#!/usr/bin/env python3.6
#!ARGS::../../f1tenth-v1/base_overlay/src/storage/stage/map/torcs/Ruudskogen.pgm
# ng_generate_data.py
"""Script for generating *.npy data from maps.
"""
######################
# Imports & Globals
######################

import sys, os, argparse

# Load PIL with preserved typing
# https://stackoverflow.com/questions/58236138/pil-and-python-static-typing
from PIL import Image as P
from PIL.Image import Image
from PIL import ImageDraw as PDraw

import numpy

# Yaml support
import yaml

# ng_trajectory utilities
#from ng_trajectory.optimizers.matryoshka.transform import pointsFilter


# Typing
from typing import List, Generator


# Custom types
class ReadableFile(object):
    """Object the check whether argument is a file that exists and is readable.

    Source:
    https://baoshangu.medium.com/python-argparse-custom-action-and-custom-type-8c8fa1e8ccb8
    """

    def __init__(self):
        super(ReadableFile, self).__init__()

    def __call__(self, filename):

        if not os.access(filename, os.R_OK):
            raise argparse.ArgumentTypeError(
                ("permission denied '%s'" if os.access(filename, os.F_OK) else "no such file '%s'") % filename
            )

        return filename


# Global variables
HOOD4 = numpy.asarray([[-1, 0], [0, -1], [1, 0], [0, 1]])
HOOD8 = numpy.asarray([[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]])
PARSER = argparse.ArgumentParser(
    prog = "ng_generate_data",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description = """
Utility for creating input data for ng_trajectory from a custom map image.

Notes:
- Arguments are position sensitive, i.e., later arguments overwrite the prior ones.
- YAML file is loaded and replaced with its arguments.
- An image is generated at the end, showing the processed data. Centerline points
  (unfiltered) are shown green, while the results (start points) are shown red.
    """,
)

# Arguments
PARSER.add_argument("input_file",
    nargs = "?",
    help = "Input source image, %%s",
    type = ReadableFile(),
    metavar = "INPUT_FILE",
)

PARSER.add_argument("-f",
    dest = "file",
    help = "Input source image, %%s",
    type = ReadableFile(),
    metavar = "INPUT_FILE",
)

PARSER.add_argument("-r", "--resize",
    dest = "resize",
    help = "Ratio to resize the source image, %%f",
    default = 1.0,
    type = float,
)

PARSER.add_argument("--resolution",
    dest = "resolution",
    help = "Resolution of the map inside source image, %%f",
    default = 1.0,
    type = float,
)

PARSER.add_argument("--ox",
    dest = "originx",
    help = "Location of origin by the x-axis, %%f meters",
    default = 0.0,
    type = float,
)

PARSER.add_argument("--oy",
    dest = "originy",
    help = "Location of origin by the y-axis, %%f meters",
    default = 0.0,
    type = float,
)

PARSER.add_argument("-y",
    dest = "yaml",
    help = "Input YAML file",
    type = ReadableFile(),
)

PARSER.add_argument("-v",
    dest = "verbose",
    help = "Give more output.",
    default = 0,
    action = "count",
)


######################
# Utilities
######################

def printv(*a, **kw) -> None:
    """Print only when verbose is set."""
    if args.verbose:
        print (*a, **kw)


def savev(im, filename: str) -> None:
    """Saves an image when verbose is set to >=2."""
    if args.verbose >= 2:
        try:
            _image = P.fromarray(im)
        except:
            _image = P.fromarray(numpy.asarray(im, dtype = numpy.uint8).copy())

        _image.convert("L")
        _image.save(filename)


def pointsFilter(points: numpy.ndarray, grid: float = None) -> numpy.ndarray:
    """Filter out points that are not necessary in trajectory planning.

    Arguments:
    points -- points to be filtered, nx2 numpy.ndarray

    Returns:
    fpoints -- filtered points, mx2 numpy.ndarray

    Note: It is expected that points are aligned to a square grid.
    Note: Extended version from Matryoshka transform.
    """

    _points = []

    # Obtain grid size if not set
    _grid = grid if grid else numpy.min(
            [
                numpy.min( numpy.subtract(u[1:], u[:-1]) ) for u in
                    [
                        numpy.unique( points[:, d] ) for d in range(points.shape[1])
                    ]
            ]
        )

    # Convert points to cell-oriented list
    _cells = [
            [ int( numpy.round(_p[_d] / _grid) ) for _d in range(points.shape[1]) ] for _p in points
        ]
    _cells_copy = [
            [ int( numpy.round(_p[_d] / _grid) ) for _d in range(points.shape[1]) ] for _p in points
        ]

    # Treat points as list
    pointsL = points.tolist()

    for _p in pointsL:
        # Remove unnecessary points.
        # _X_  ___  ___  _X_  |  _XX  __X  ___  ___  ___  ___  X__  XX_
        # _XX  _XX  XX_  XX_  |  _X_  _XX  _XX  _X_  _X_  XX_  XX_  _X_
        # ___  _X_  _X_  ___  |  ___  ___  __X  _XX  XX_  X__  ___  ___
        # But also endpoints (iteratively)
        # X__  _X_  __X  ___  ___  ___  ___  ___
        # _X_  _X_  _X_  _XX  _X_  _X_  _X_  XX_
        # ___  ___  ___  ___  __X  _X_  X__  ___
        # Convert points to a cell
        _cell = [ int( numpy.round(_p[_d] / _grid) ) for _d in range(points.shape[1]) ]

        # Ranges
        _xr = range(-1, 2)
        _yr = range(-1, 2)

        # Count number of points in the area (x-wise, y-wise)
        x = [ sum([ [ _cell[0] + _x, _cell[1] + _y ] in _cells for _y in _yr ]) for _x in _xr ]
        y = [ sum([ [ _cell[0] + _x, _cell[1] + _y ] in _cells for _x in _xr ]) for _y in _yr ]
        x_sum = sum([ _x > 0 for _x in x ])
        y_sum = sum([ _y > 0 for _y in y ])

        # Count the points on HOOD4
        # _._
        # ...
        # _._
        x_4 = sum([ [ _cell[0] + _x, _cell[1]      ] in _cells for _x in _xr ])
        y_4 = sum([ [ _cell[0],      _cell[1] + _y ] in _cells for _y in _yr ])

        # Second part resolves issues with multiple centerlines being improperly filtered
        # __X  _XX  _X_  __X  __X
        # _XX  _XX  _XX  _XX  _XX
        # __X  __X  __X  _XX  _X_
        # and their rotations
        if ( ( x_sum < 3 ) and ( y_sum < 3 ) ) or \
            (x_sum + y_sum == 5 and (x_4 == y_4 == 2 or (x_4 + y_4 == 3 and 3 in x + y))):
            # Return nearby points back to the loop
            for _xr in range(-1, 2):
                for _yr in range(-1, 2):
                    if _xr == _yr == 0:
                        continue

                    # Get index of the cell
                    _nearbyc = [ _cell[0] + _xr, _cell[1] + _yr ]

                    # Find whether it is a valid border cell and try to find it
                    if _nearbyc in _cells_copy and pointsL[_cells_copy.index(_nearbyc)] in _points:
                        _nearbyp = pointsL[_cells_copy.index(_nearbyc)]
                        _points.remove(_nearbyp)
                        pointsL.append(_nearbyp)

            _cells.remove(_cell)

        else:
            _points.append(_p)

    return numpy.asarray(_points)


######################
# Centerline generation
######################

def getWalls(im: Image) -> List[numpy.ndarray]:
    """Get wall sequences from the image.

    Arguments:
    im -- source image, Image

    Returns:
    walls -- sets of points belonging to walls, m-list of x2 numpy.ndarray

    Sources:
    https://stackoverflow.com/questions/46083880/fill-in-a-hollow-shape-using-python-and-pillow-pil
    """

    # Duplicate image
    _im = im.copy()

    # Obtain wall color
    # Note: In grayscale image, 0 is black, 1 is white.
    hist = numpy.asarray(_im.histogram())
    wall_color = numpy.argwhere(hist == hist[hist > 0][0])[0][0]

    walls = []

    # Progress
    starting_value = _im.histogram()[wall_color]

    while _im.histogram()[wall_color] > 0:

        # Convert image to numpy array
        _nd = numpy.asarray(_im)

        # Find specified color somewhere
        _wall = numpy.argwhere(_nd == wall_color)[0]

        # Use PIL fill tool to color the wall
        _color = numpy.argwhere(numpy.asarray(_im.histogram()) == 0)[0][0]
        PDraw.floodfill(
            _im,
            xy = (int(_wall[1]), int(_wall[0])),
            value = int(_color),
            thresh = 0,
        )

        # Recast image to numpy
        _nd = numpy.asarray(_im)

        # Get coordinates of newly colored walls
        walls.append(
            numpy.argwhere(
                _nd == _color
            )
        )

        sys.stdout.write("\rObtaining walls... %03.2f%%" % (100.0 - (100.0 * _im.histogram()[wall_color] / starting_value)))

    print (" - DONE")

    # We sort the walls in descending size
    # i.e., indices here are not the same as latter ones,
    # but that is ok.
    walls = sorted(walls, key = lambda x: -len(x))

    if args.verbose:
        print ("Found %d walls:" % len(walls))
        print ("\n".join(["\t Wall %d: length %d" % (_i + 1, len(wall)) for _i, wall in enumerate(walls)]))

    return walls


######################
# PIL functions
######################

def intersectArrays(arr1: numpy.ndarray, arr2: numpy.ndarray) -> numpy.ndarray:
    """Receive rows that are present in both arrays.

    Arguments:
    arr1, arr2 -- input array, numpy.ndarray

    Returns:
    iarr -- intersection of both arrays, numpy.ndarray

    Source:
    # https://stackoverflow.com/questions/9269681/intersection-of-2d-numpy-ndarrays
    """

    arr1_view = arr1.view([('',arr1.dtype)]*arr1.shape[1])
    arr2_view = arr2.view([('',arr2.dtype)]*arr2.shape[1])
    intersected = numpy.intersect1d(arr1_view, arr2_view)
    return intersected.view(arr1.dtype).reshape(-1, arr1.shape[1])


def processImage(im: Image) -> None:
    """Loads an image from the file and generates .npy data.

    Arguments:
    im -- loaded image
    """

    # Get walls
    walls = getWalls(im)

    # Create numpy array
    nd = numpy.asarray(im, dtype = int)
    # Helper array
    nd_walls = numpy.zeros_like(im, dtype = int)

    # Name colors (just in case)
    try:
        WALL, UNKN, FREE = numpy.unique(nd)
    except:
        WALL, FREE = numpy.unique(nd)


    ## Inflate walls

    # Obtain all empty spaces
    _free = numpy.argwhere(nd == FREE).copy()

    # Wall "iterator"
    _w = 0

    # Color initial walls
    for i in range(len(walls)):
        nd_walls[walls[i][:, 0], walls[i][:, 1]] = i + 1

    starting_value = len(_free)

    # Until there are no more free elements left
    while len(_free) > 0 and max([ len(wall) for wall in walls]) > 0:

        # Obtain all walls of one color and replicate it
        # https://stackoverflow.com/questions/53239242/how-to-duplicate-each-row-of-a-matrix-n-times-numpy
        _wall = numpy.repeat(walls[_w], repeats = HOOD4.shape[0], axis = 0)

        # Find the neighbourhood
        _hood = numpy.add(
            _wall,
            numpy.tile(HOOD4, reps = (walls[_w].shape[0], 1))
        )

        # Throw away points that are outside the image and remove duplicits
        _hood = numpy.unique(_hood[~numpy.any((_hood < 0) | (_hood >= nd.shape), axis = 1), :], axis = 0)

        # Find all free points that are also in the neighbourhood
        _new_wall = _hood[numpy.where(nd_walls[_hood[:, 0], _hood[:, 1]] == 0)[0], :]

        # Mark newly found walls
        nd[_new_wall[:, 0], _new_wall[:, 1]] = _w + 1
        nd_walls[_new_wall[:, 0], _new_wall[:, 1]] = _w + 1
        
        # Save these walls for the next iteration
        walls[_w] = _new_wall

        # Prepare variables for new iteration
        _w = (_w + 1) % len(walls)
        _free = numpy.argwhere(nd == FREE).copy()

        sys.stdout.write("\rInflating map... %03.2f%%" % (100.0 - (100.0 * len(_free) / starting_value)))

    print (" - DONE")
    printv ("Covered all of %d free cells." % starting_value)

    if args.verbose >= 2:
        _nd_walls = nd_walls.copy()
        _nd_walls = (_nd_walls * 30) % 255
        _nd_walls[numpy.where(_nd_walls == 0)] = 255
        savev (_nd_walls, "inflated.png")
        printv ("Saved inflated map to 'inflated.png'.")


    ## Obtain centerline
    sys.stdout.write("\rGenerating centerline...")

    border = []
    wall_len_1 = 0
    nd2 = numpy.asarray(im, dtype = int)

    # Get neighbourhood of a wall where it meets different walls.
    for wall_index_1 in range(1, len(walls) + 1):

        wall_1 = numpy.argwhere(nd_walls == wall_index_1)

        # Obtain all walls of one color and replicate it
        # https://stackoverflow.com/questions/53239242/how-to-duplicate-each-row-of-a-matrix-n-times-numpy
        _wall = numpy.repeat(wall_1, repeats = HOOD4.shape[0], axis = 0)

        # Find the neighbourhood
        _hood = numpy.add(
            _wall,
            numpy.tile(HOOD4, reps = (wall_1.shape[0], 1))
        )

        # Throw away points that are outside the image and remove duplicits
        _hood = numpy.unique(_hood[~numpy.any((_hood < 0) | (_hood >= nd.shape), axis = 1), :], axis = 0)

        # Find all points of other walls
        # Copy is required as argwhere returns 2xn array with nx2 view,
        # which is unfortunately incompatible with current intersect function.
        _other_walls = numpy.argwhere(nd_walls > wall_index_1).copy()

        # Find all free points that are also in the neighbourhood
        # And append them to the current skeleton
        border += intersectArrays(
            intersectArrays(_hood, _other_walls),
            numpy.argwhere(nd2 == FREE).copy()
        ).tolist()

        if wall_index_1 == 1:
            wall_len_1 = len(border)

    border = numpy.asarray(border)
    print (" - DONE")
    printv ("Centerline has length %d." % len(border))


    ## Remove duplicits of centerline points
    border = numpy.unique(border, axis = 0)


    ## Filter centerline points
    sys.stdout.write("\rFiltering points...")
    filtered_border = pointsFilter(border).tolist()
    if len(filtered_border) < 1:
        print (" - FAILED")
        printv ("Using the centerline of largest wall, as filter removed everything.")
        printv ("Centerline has %d points." % wall_len_1)
        filtered_border = border.tolist()[0:wall_len_1]
    else:
        print (" - DONE")
        printv ("Reduced centerline to %d points." % len(filtered_border))


    ## Sort centerline points
    # Note: This is an adapted version from 'ng_trajectory:trajectorySort()'.
    sorted_points = []
    _filtered_border = filtered_border.copy()
    sorted_points.append(_filtered_border.pop(0))

    starting_value = len(_filtered_border)

    while len(_filtered_border) > 0:
        min_dist = 100000
        point = None

        for p in _filtered_border:
            dist = numpy.hypot(p[0] - sorted_points[-1][0], p[1] - sorted_points[-1][1])

            if dist < min_dist:
                min_dist = dist
                point = p

        sorted_points.append(point)
        _filtered_border.remove(point)

        sys.stdout.write("\rSorting points... %03.2f%%" % (100.0 - (100.0 * len(_filtered_border) / starting_value)))

    print (" - DONE")

    sorted_points = numpy.asarray(sorted_points)


    ## Create and save image of the situation
    sys.stdout.write("\rSaving the data...")

    nnd = numpy.asarray(im.convert("RGB"))
    try:
        nnd[border[:, 0], border[:, 1]] = [0, 255, 0]
        for x, y in filtered_border:
            nnd[x, y] = [255, 0, 0]
    except:
        pass

    nndi = P.fromarray(nnd)
    nndi.save("generated_data.png")


    ## Save into npy

    start_points = numpy.asarray(sorted_points).astype(float)

    # Flip y-axis
    start_points -= [im.size[1], 0]
    start_points[:, 0] = numpy.abs(start_points[:, 0])

    # Convert to real units (if required)
    if args.resolution != 1.0:# or args.resize != 1.0:
        start_points *= args.resolution / args.resize

    # Move the origin (if required)
    if args.originx != 0.0 or args.originy != 0.0:
        start_points += [args.originy, args.originx]

    # Swap yx
    start_points = numpy.vstack((start_points[:, 1], start_points[:, 0])).T

    numpy.save("start_points.npy", start_points)

    valid_points = numpy.asarray(im, dtype = int)
    valid_points = numpy.argwhere(valid_points == FREE).astype(float)

    # Flip y-axis
    valid_points -= [im.size[1], 0]
    valid_points[:, 0] = numpy.abs(valid_points[:, 0])

    # Convert to real units (if required)
    if args.resolution != 1.0:# or args.resize != 1.0:
        valid_points *= args.resolution / args.resize

    # Move the origin (if required)
    if args.originx != 0.0 or args.originy != 0.0:
        valid_points += [args.originy, args.originx]

    # Swap yx
    valid_points = numpy.vstack((valid_points[:, 1], valid_points[:, 0])).T

    numpy.save("valid_points.npy", valid_points)

    print (" - DONE")

    
def loadImage(filename: str) -> Image:
    """Loads an image from the file and prepares it for processing.

    Arguments:
    filename -- path to the file, str

    Returns:
    im -- loaded image

    Sources:
    https://stackoverflow.com/questions/1065945/how-to-reduce-color-palette-with-pil
    https://stackoverflow.com/questions/236692/how-do-i-convert-any-image-to-a-4-color-paletted-image-using-the-python-imaging-l
    """

    im = P.open(filename)
    im = im.resize((int(im.size[0]*args.resize), int(im.size[1]*args.resize)), resample = P.BILINEAR)

    has_alpha = False

    printv ("Loaded image:", im)

    # Verify used palette
    # Note: Only "L" is now usable.
    if im.mode != "L":
        # Support also "LA" by removing the alpha channel.
        # TODO: Check whether RGBA works as well.
        if im.mode == "LA" or im.mode == "RGBA":
            # Save alpha channel and convert it into two colors
            alpha_nd = numpy.asarray(im.split()[-1].quantize(2, method = 1), dtype = int)

            has_alpha = True

        im = im.convert("L")

        #print ("Unsupported image mode %s, currently only %s is/are supported."
        #    % (
        #        im.mode,
        #        ["L"],
        #    ), file = sys.stderr
        #)

    # Obtain three most used colors
    colors = []
    hist = im.histogram()

    while len(colors) < 3:
        _index = hist.index(max(hist))
        colors.append(_index)
        hist[_index] = min(hist) - 1

    # Create palette for quantization image
    palette = []

    for color in colors:
        palette += [color, ] * 3

    # Fill the rest of the palette
    palette += [0, ] * 3 * (256 - len(palette))

    # Create image for quantization
    imQ = P.new("P", (1, 1), 0)
    imQ.putpalette(palette)

    # Convert source image to RGB
    im = im.convert("RGB")

    # Quantize colors in the image
    # For some reason 'method = 1' is much worse for resized images.
    im = im.quantize(3, method = 0)#palette = imQ) <- Palette is broken with rescaled images? (returns 4 colors instead of 3)

    # Convert the image back to grayscale
    im = im.convert("L")

    # Add the removed alpha channel
    if has_alpha:
        UNKN = numpy.unique(numpy.asarray(im))[1]

        for r, c in numpy.argwhere(alpha_nd == 0):
            im.putpixel((int(c), int(r)), int(UNKN))

    return im

    # Not used now, as it seems that it is not necessary with
    # im.quantize(method = 0)

    ## Fix missaligned colors
    # When changing the size, free space can appear outside the track and unknown inside.

    # Obtain numpy array to locate colors
    nd = numpy.asarray(im)
    WALL, UNKN, FREE = numpy.unique(nd)

    # Obtain all free spaces
    free = numpy.argwhere(nd == FREE)

    # 1: Find inner area of the track
    for r, c in free:
        for _r, _c in HOOD8:
            if nd[r + _r, c + _c] != FREE:
                break
        else:
            break
    else:
        return im

    # 2: Color all free to unknown
    starting_value = im.histogram()[FREE]

    while im.histogram()[FREE] > 0:

        # Convert image to numpy array
        nd = numpy.asarray(im)

        # Find specified color somewhere
        free = numpy.argwhere(nd == FREE)[0]

        # Use PIL fill tool to color the place
        PDraw.floodfill(
            im,
            xy = (int(free[1]), int(free[0])),
            value = int(UNKN),
            thresh = 0,
        )

        # Recast image to numpy
        nd = numpy.asarray(im)

        sys.stdout.write("\rClearing resize fragments... %03.2f%%" % (100.0 - (100.0 * im.histogram()[FREE] / starting_value)))

    print (" - DONE")

    # 3: Finally, fill the inside section back again to free        
    PDraw.floodfill(
        im,
        xy = (int(c), int(r)),
        value = int(FREE),
        thresh = 0,
    )

    return im


######################
# Main
######################

if __name__ == "__main__":

    # Obtain arguments
    args = PARSER.parse_args()

    # Check whether yaml is set
    if args.yaml is not None:
        with open(args.yaml, "r") as file:
            try:
                yaml_data = yaml.safe_load(file)
            except Exception as e:
                print ("Unable to parse YAML file: %s" % e, file=sys.stderr)
                exit (22)

        # Remove yaml from arguments
        index = 0
        for index, _arg in enumerate(sys.argv):
            if _arg == "-y":
                del sys.argv[index+1], sys.argv[index]
                break

        # Load yaml into the args
        if "image" in yaml_data:
            _image = str(yaml_data.get("image"))

            sys.argv.insert(index,
                _image if os.path.isabs(_image) or os.path.exists(_image) else os.path.dirname(args.yaml) + os.sep + _image
            )
            sys.argv.insert(index, "-f")

        # Resolution
        if "resolution" in yaml_data:
            sys.argv.insert(index, str(yaml_data.get("resolution")))
            sys.argv.insert(index, "--resolution")

        # Origin
        if "origin" in yaml_data:
            sys.argv.insert(index, str(yaml_data.get("origin")[0]))
            sys.argv.insert(index, "--ox")

            sys.argv.insert(index, str(yaml_data.get("origin")[1]))
            sys.argv.insert(index, "--oy")


    args = PARSER.parse_args()

    if args.verbose:
        print ("Interpreted arguments:")
        print ("\n".join([ "\t%s: %s" % (key, value) for key, value in args._get_kwargs() ]))


    # Use positional file if optional not given
    if args.file is None:
        if args.input_file is None:
            print ("Expected argument with path to the source image.", file=sys.stderr)
            exit(10)
        else:
            args.file = args.input_file

    # Run the program
    im = loadImage(args.file)
    processImage(im)


